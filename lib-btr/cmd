#!/usr/bin/env bash

__run () {
    # TODO: change logic: all commands don't require the mountpoints etc.
    __init

    __parse_cmd "$@"
}

__parse_cmd () {
    case "$1" in
        bootstrap)
            shift
            __require_root
            __cmd_bootstrap "$@"
            exit ;;
        create)
            shift
            __require_root
            __cmd_create "$@"
            exit ;;
        destroy)
            shift
            __require_root
            __cmd_destroy "$@"
            exit ;;
        list)
            shift
            __cmd_list "$@"
            exit ;;
        snaplist)
            shift
            __cmd_snaplist "$@"
            exit ;;
        snapshot)
            shift
            __require_root
            __cmd_snapshot "$@"
            exit ;;
        snapremove)
            shift
            __require_root
            __cmd_snapremove "$@"
            exit ;;
        set)
            shift
            __require_root
            __cmd_set "$@"
            exit ;;
        get)
            shift
            __cmd_get "$@"
            exit ;;
        help)
            shift
            __cmd_help
            exit ;;
        find)
            shift
            __cmd_find "$@"
            exit ;;
        *)
            shift
            __cmd_help >&2
            exit 1 ;;
    esac
}

__cmd_create () {
    local _mountpoint _escaped_name _path

    _mountpoint="$1"
    _escaped_name="$(__escape "$_mountpoint")"
    _path="$butter_host"/"$_escaped_name"

    __require_bootstrapped
    btrfs subvolume create "$butter_root/$_path"
    __set_one_prop "mountpoint" "$_mountpoint" "$butter_root/$_path"
    __set_one_prop "snapshot.default.max" "5" "$butter_root/$_path"
    __set_one_prop "snapshot.is" "0" "$butter_root/$_path"
    __set_one_prop "uuid" "$(uuidgen -r)" "$butter_root/$_path"
}

__cmd_destroy () {
    local _mountpoint _subvolumes _sub

    _mountpoint="$1"
    mapfile -t _subvolumes < <(__find_all "mountpoint" "$_mountpoint")

    for _sub in "${_subvolumes[@]}"; do
        btrfs subvolume delete -- "$_sub"
    done
}

__cmd_list () {
    local _paths _path _mountpoint _uuid

    mapfile -t _paths < <(__find_all "snapshot.is" "0" "$@")
    { printf '%s^%s\n' "MOUNTPOINT" "UUID"
    for _path in "${_paths[@]}"; do
        _mountpoint="$(__get_one_prop "mountpoint" "$_path")"
        _uuid="$(__get_one_prop "uuid" "$_path")"
        printf '%s^%s\n' "$_mountpoint" "$_uuid"
    done } | column -ts^
}

__cmd_snapshot () {
    local _mountpoint _path _snaptype _snaplist _max _to_delete _number

    _args=("$@")

    _mountpoint="$1"
    _path="$(__find_path "$_mountpoint")"

    shift

    # we extract the snapshot type
    while (( $# > 1 )); do
        if [[ "$1" == "type" ]]; then
            _snaptype="$2"
        fi
        shift 2
    done
    _snaptype="${_snaptype:-default}"

    _max="$(__get_one_prop "snapshot.${_snaptype}.max" "$_path")"
    [[ -z "$_max" ]] && _max=5

    if (( _max != 0 )); then
        # We take a snapshot
        __do_snapshot "${_args[@]}"

        # We make sure to honor "snapshot.$_snaptype.max"
        mapfile -t _snaplist < <(__find_all_sort "snapshot.timestamp" \
          "snapshot.type" "$_snaptype" "mountpoint" "$_mountpoint"\
          "snapshot.is" "1")

        if (( "${#_snaplist[@]}" > "$_max" )); then
            _to_delete=$(( ${#_snaplist[@]} - $_max ))
            for ((_number=0;_number<$_to_delete;_number++)); do
                btrfs subvolume delete -- "${_snaplist[$_number]}"
            done
        fi
    fi
}

# Take a snapshot of a given mountpoint, assign it lots of properties
# usage: __do_snapshot PATH [PROP VALUE [...]]
__do_snapshot () {
    local _mountpoint _path _date _uuid _to_path _prop _value

    _mountpoint="$1"
    _path="$(__find_path "$_mountpoint")"

    shift

    _date="$(date "+%s")"
    _uuid="$(uuidgen -r)"
    _to_path="$_path@$_uuid"
    _tmp_path="${_to_path}.tmp"

    # a temporary snapshot because btrfs(8) still sucks
    btrfs subvolume snapshot -- "$_path" "$_tmp_path"

    while (( $# > 1 )); do
        _prop="$1"
        _value="$2"

        __set_one_prop "snapshot.$_prop" "$_value" "$_tmp_path"
        shift 2
    done

    # we set the timestamp
    __set_one_prop "snapshot.timestamp" "$_date" "$_tmp_path"
    # we set an uuid
    __set_one_prop "uuid" "$_uuid" "$_tmp_path"
    # we set the snapshot boolean
    __set_one_prop "snapshot.is" "1" "$_tmp_path"

    # we set the snapshot type if none was set
    if ! __get_one_prop "snapshot.type" "$_tmp_path"; then
        __set_one_prop "snapshot.type" "default" "$_tmp_path"
    fi

    # we snapshot read-only
    btrfs subvolume snapshot -r -- "$_tmp_path" "$_to_path"
    btrfs subvolume delete -- "$_tmp_path"
}

__cmd_snapremove () {
    local _mountpoint _number _snaplist

    _mountpoint="$1"
    _number="${2:-5}"

    shift 2

    mapfile -t _snaplist < <(__find_all_sort "snapshot.timestamp" "snapshot.is" 1 \
                                 "mountpoint" "$_mountpoint" \
                                 "$@")

    for ((_num=0; _num < $_number; _num++)); do
        if [[ -n "${_snaplist[$_num]}" ]]; then
            btrfs subvolume delete -- "${_snaplist[$_num]}"
        fi
    done
}


__cmd_snaplist () {
    local _snaplist _subvolume _mountpoint _uuid _type _date

    mapfile -t _snaplist < <(__find_all "snapshot.is" "1")
    {
    printf '%s^%s^%s^%s\n' 'MOUNTPOINT' 'TYPE' 'DATE' 'UUID'
    {
    for _subvolume in "${_snaplist[@]}"; do
        _mountpoint="$(__get_one_prop "mountpoint" "$_subvolume")"
        _uuid="$(__get_one_prop "uuid" "$_subvolume")"
        _type="$(__get_one_prop "snapshot.type" "$_subvolume")"
        _date="$(date --date=@"$(__get_one_prop "snapshot.timestamp" \
          "$_subvolume")")"
        printf '%s^%s^%s^%s\n' "$_mountpoint" "$_type" "$_date" "$_uuid"
    done
    } | sort -n
    } | column -ts^
}

__cmd_set () {
    local _prop _value _mountpoint _path _new_path

    __require_bootstrapped
    _mountpoint="$1"
    _path="$(__find_path "$_mountpoint")"
    shift

    while (( $# > 1 )); do
        _prop="$1"
        _value="$2"

        __require_in_props "$_prop"

        # We cannot change some properties
        case "$_prop" in
            "mountpoint") __fatal "nope";;
            "uuid") __fatal "nope";;
            "snapshot.is") __fatal "nope";;
        esac
 
        __set "$butter_prop_prefix.$_prop" "$_value" "$_path"

        shift 2
    done
}

__cmd_get () {
    local _prop _mountpoint

    _mountpoint="$1"
    _path="$(__find_path "$_mountpoint")"
    shift

    __require_bootstrapped
    
    {
    printf '%s^%s^%s\n' "MOUNTPOINT" "PROP" "VALUE"
    for _prop in "$@"; do
        __require_in_props "$_prop"
        _value="$(__get "$butter_prop_prefix.$_prop" "$_path")"
        printf '%s^%s^%s\n' "$_mountpoint" "$_prop" "$_value"
    done } | column -ts^
}

__cmd_help () {
    __print_help
}

__cmd_bootstrap () {
    __info "butter root is $butter_root"
    __bootstrap
    __require_bootstrapped
}

__cmd_find () {
    __find_all "$@"
}

__require_root () {
    [[ -w "$butter_root" ]] || __fatal "Can't write to $butter_root"
}
