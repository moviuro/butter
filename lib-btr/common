#!/usr/bin/env bash

__fatal () {
    printf '%s\n!! %s\n' "Fatal error" "$1"
    exit 2
}

__info () {
    printf '%s\nII %s\n' "Information" "$1"
}

__get () {
    getfattr --only-values --name "$1" "$2" 2>/dev/null
}

__set () {
    setfattr --name "$1" --value "$2" "$3"
}

__get_one_prop () {
    local _prop _path

    _prop="$1"
    _path="$2"

    __require_in_props "$_prop"
    __get "$butter_prop_prefix"."$_prop" "$_path"
}

__set_one_prop () {
    local _prop _value _path

    _prop="$1"
    _value="$2"
    _path="$3"

    __require_in_props "$_prop"
    __set "$butter_prop_prefix"."$_prop" "$_value" "$_path"
}

__require_in_props () {
    local _prop _found _item

    _prop="$1"
    _found=0

    for _item in "${butter_prop_array[@]}"; do
        if [[ "$_prop" = $_item ]]; then
            _found=1
            continue
        fi
    done

    (( _found )) ||  __fatal "Unknown property: $_prop"
}

__escape () {
    # TODO: better escaping function? (systemd-independant)
    systemd-escape "$1"
}

__find_path () {
    local _mountpoint _escaped

    _mountpoint="$1"
    _escaped="$(__escape "$_mountpoint")"

    if [[ -d "$butter_root/$butter_host/$_escaped" ]]; then
        printf '%s\n' "$butter_root/$butter_host/$_escaped"
    else
        __fatal "Couldn't find path to $_mountpoint"
    fi
}

# Returns a \n-seperated list of paths which match some properties
# usage: __find_all [PROP VALUE [...]]
__find_all () {
    local _path _show _prop _thing _value
    for _path in "$butter_root/$butter_host/"*; do
        _show=1
        _prop=""
        for _thing in "$@"; do
            if [[ -z "$_prop" ]]; then
                _prop="$_thing"
            else
                _value="$_thing"
                if [[ "$(__get_one_prop "$_prop" "$_path")" != "$_value" ]]; then
                    _show=0
                    break
                fi
                _prop=""
            fi
        done
        if (( _show )); then
            printf '%s\n' "$_path"
        fi
    done
}
